# Консольные крестики-нолики

## Задание

Написать консольную игру - крестики-нолики. Требуется, чтобы два пользователя
по очереди вводили клетку, в которую хотят поставить крестик или нолик.
Приложение должно отвечать текущим состоянием поля.

Нужно параметризовать размер поля переменной окружения. Поле должно быть квадратным.
Длина квадрата должна быть от 3 клеток.

Приложение должно быть написано с учетом нефункциональных требований:

- Полностью функциональный код, все должны быть написано с использованием IO-монады
- Приложение должно быть покрыто тестами, сборка должна падать при недостаточном покрытии
- Приложение должно собираться в архив, должна быть приложена инструкция по запуску

## Как запустить

Запускается просто командой 

``` sh
sbt clean run 
```

Если есть желание изменить размер поля (стандартное -- 3х3), то это можно сделать при запуске, например, командой
``` sh
export fieldSize=<your size> && sbt clean run
```

P.S -- вернуть дефолтное поведение можно через команду `unset fieldSize`.

Кроме того при первом запуске полезно будет запустить тесты:

``` sh
sbt compile coverage test coverageReport
```


## Общая архитектура

Лучшая документация -- это код, в нем полно комментариев, которые, надеюсь, делают код немного более понятным. Ниже вынесены основные компоненты из которых состоит проект. Данный план составлялся еще до начала реализации проекта, поэтому может содержать некоторые неточности и недомолвки.

### GameEngine 

Прежде всего у нас есть класс `GameEngine`, который заточен под некоторый способ ввода/вывода и ответственен за всю неигровую логику:
* обработку задекларированных команд, таких как "exit" (остановка программы), "help" (вывод списка доступных команд и правил игры) и подобных;
* вывод приветствия в начале и предложения начать новую игру в конце.

Вся игровая логика заключена в интерфейс `GameState` (см. описание `GameState`), реализацию которого параметром принимает интерфейс GameEngine (его главный метод `run(s: GameState)`). Все незадекларированные команды передаются на обработку в реализацию `GameState`, а полученые из нее состояния поля, ошибки хода и результат игры `GameEngine` выводит в консоль игрокам после каждой команды. Таким образом класс `GameEngine` полностью отвечает за `IO`, давая возможность методам `GameState` быть чистыми и легко тестируемыми, а так же легко тестировать `IO` через `Mock`-реализацию `GameState` (правда `mock`-реализации `IO` по дефолту я не нашел, так что пришлось делать костыли самому).

В нашей реализации `GameEngine` принимает тайп-параметр, реализующий специальный трейт `IConsole`, который позволяет заменить `IO` в будущем на любой другой вывод, да хоть, например, на сервер на веб-сокете, а так же позволяет замокать `IO` и нормально протестировать `GameEngine`.

*Замечание: * Разделить две эти зоны ответственности (`IConsole` и неигровую логику) без дополнительных ограничений не представляется возможным, т.к в зависимости от реализации нашего `IO` меняется и реализация неигровой логики. Например, при работе из консоли нам гарантруется, что игроки ходят в нужном порядке, но если же у нас будет веб-сервер, то придется самим решать чей ввод сейчас принимать (чей ход сейчас). Кроме того при большом количестве асинхронных сессий данный класс еще разрастется, чтобы содержать целый пул инстансов `GameState` для каждой отдельной сессии.


### GameState

Сам GameState -- это интерфейс, который описывает логику конкретной игры. Каждый инстанс GameState хранит в себе каким-то образом состояние игры и предоставляет следующий API:
* умеет распарсив строку записать ход игрока создав новый стейт -- processState(String): Either[String, GameState]
* проверить завершена ли игра -- isDone: Option[String]
* вернуть строку, визуализирующую состояние игры
* вернуть строку, означающую чей сейчас ход

В зависимости от правил в будущем вполне логично ожидать более сложных правил нежели крестики-нолики. Так, например, древнекитайская игра гомоку аналогична крестикам-ноликам, но имеет поле ровно 19x19 и для выигрыша требует выложить ровно 5 крестиков/ноликов в ряд (горизонтально, вертикально или по диагонали). Данный интерфейс позволяет формализовать +- любую настолку без скрытого состояния: шахматы, шашки, го. 

В данном случае мы получим класс GameStateTTT (Tic-Tac-Toe)

В нашей реализации так же принимается некоторая реализация трейта `Space`, который позволяет сделать наши типы более безопасными: после инициализации у нас нет возможности в `GameState` записать невалидное значение и ответственность за это вынесена в соответствующий `implicit`. 

### Тестируемость и отладка

Каждая компонента может быть легко заменена mock'ом. Вся логика вынесена из GameEngine (который работает с IO) в классы с чистыми функциями, которые можно тестировать отдельно. Таким образом тестировать и отлаживать все компоненты должно быть легко. В проекте настроен минимальный порог покрытия тестами, так что все поведение более-менее протестировано.
